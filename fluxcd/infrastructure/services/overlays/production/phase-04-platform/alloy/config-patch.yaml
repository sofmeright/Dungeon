apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
data:
  config.alloy: |
    // ==========================================================================
    // Kubernetes Service Discovery
    // Node-scoped where possible to minimize API server load and memory usage.
    // Each DaemonSet pod only watches objects relevant to its own node.
    // ==========================================================================

    // Pods on this node only (field selector reduces cache from ~650 to ~60 pods)
    discovery.kubernetes "pods" {
      role = "pod"
      selectors {
        role  = "pod"
        field = "spec.nodeName=" + env("HOSTNAME")
      }
    }

    // This node only (1 node instead of 10)
    discovery.kubernetes "nodes" {
      role = "node"
      selectors {
        role  = "node"
        field = "metadata.name=" + env("HOSTNAME")
      }
    }

    // Services cluster-wide (needed for annotation-based scraping, relatively small)
    discovery.kubernetes "services" {
      role = "service"
    }

    // Endpoints scoped to kube-system only (used solely for CoreDNS discovery)
    discovery.kubernetes "endpoints" {
      role = "endpoints"
      namespaces {
        names = ["kube-system"]
      }
    }

    // Removed: endpointslices (unused - nothing referenced it)
    // Removed: ingresses (unused - nothing referenced it)

    // ==========================================================================
    // Prometheus Remote Write - Direct to VictoriaMetrics vminsert
    // ==========================================================================
    prometheus.remote_write "default" {
      endpoint {
        url = "http://vminsert.gossip-stone.svc.cluster.local:8480/insert/0/prometheus/api/v1/write"

        queue_config {
          capacity             = 2500
          max_shards           = 4
          min_shards           = 1
          max_samples_per_send = 500
          batch_send_deadline  = "15s"
          min_backoff          = "500ms"
          max_backoff          = "30s"
          retry_on_http_429    = true
        }
      }
    }

    // ==========================================================================
    // Global metric relabeling - drop high-cardinality metrics and bloated labels
    // ==========================================================================
    prometheus.relabel "drop_high_cardinality" {
      forward_to = [prometheus.remote_write.default.receiver]

      // DROP: Histogram buckets - massive cardinality, _sum/_count give rate + avg latency
      rule {
        source_labels = ["__name__"]
        regex         = ".*_bucket"
        action        = "drop"
      }

      // DROP: Per-device blkio metrics - per-RBD granularity is overkill
      rule {
        source_labels = ["__name__"]
        regex         = "container_blkio_device_usage_total"
        action        = "drop"
      }

      // DROP: All GitLab and Sidekiq metrics - 10,000+ high-cardinality internal metrics
      rule {
        source_labels = ["__name__"]
        regex         = "(gitlab|sidekiq)_.+"
        action        = "drop"
      }

      // DROP: API server metrics for rarely-used CRD resources
      rule {
        source_labels = ["__name__", "resource"]
        regex         = "apiserver_.+;(ipaddresses|resourceclaims|operatorconfigs|cephobjectzones|redissentinels)"
        action        = "drop"
      }

      // DROP: etcd metrics for rarely-used CRD resources
      rule {
        source_labels = ["__name__", "resource"]
        regex         = "etcd_.+;(ipaddresses|resourceclaims|operatorconfigs|cephobjectzones|redissentinels)"
        action        = "drop"
      }

      // Preserve select container_label_* fields via temp labels, then drop the rest
      rule {
        source_labels = ["container_label_com_docker_compose_project"]
        target_label  = "compose_project_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["container_label_com_docker_compose_service"]
        target_label  = "compose_service_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["container_label_com_docker_compose_config_hash"]
        target_label  = "compose_config_hash_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["container_label_com_docker_compose_container_number"]
        target_label  = "compose_container_number_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["container_label_com_docker_compose_image"]
        target_label  = "compose_image_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["container_label_com_docker_compose_project_working_dir"]
        target_label  = "compose_working_dir_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      // Drop ALL container_label_* labels
      rule {
        action = "labeldrop"
        regex  = "container_label_.*"
      }

      // Rename temp labels back to proper names
      rule {
        source_labels = ["compose_project_temp"]
        target_label  = "compose_project"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["compose_service_temp"]
        target_label  = "compose_service"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["compose_config_hash_temp"]
        target_label  = "compose_config_hash"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["compose_container_number_temp"]
        target_label  = "compose_container_number"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["compose_image_temp"]
        target_label  = "compose_image"
        regex         = "(.*)"
        replacement   = "$1"
      }
      rule {
        source_labels = ["compose_working_dir_temp"]
        target_label  = "compose_working_dir"
        regex         = "(.*)"
        replacement   = "$1"
      }

      // Drop temp labels
      rule {
        action = "labeldrop"
        regex  = "compose_(project|service|config_hash|container_number|image|working_dir)_temp"
      }
    }

    // ==========================================================================
    // NODE-LOCAL METRICS (no clustering - each DaemonSet pod scrapes its own node)
    // ==========================================================================

    // Built-in Node Exporter - host metrics from each K8s node
    prometheus.exporter.unix "node_metrics" {
    }

    prometheus.scrape "node_exporter" {
      targets    = prometheus.exporter.unix.node_metrics.targets
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel for kubelet scraping (local node only via field selector on discovery)
    discovery.relabel "kubelet" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }
      rule {
        replacement  = "/metrics"
        target_label = "__metrics_path__"
      }
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    prometheus.scrape "kubelet" {
      targets    = discovery.relabel.kubelet.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scheme            = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // cAdvisor (local node only)
    discovery.relabel "cadvisor" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }
      rule {
        replacement  = "/metrics/cadvisor"
        target_label = "__metrics_path__"
      }
      rule {
        replacement  = "cadvisor"
        target_label = "job"
      }
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    prometheus.scrape "cadvisor" {
      targets    = discovery.relabel.cadvisor.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scheme            = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Kubelet resource metrics (local node only)
    discovery.relabel "kubelet_resource" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }
      rule {
        replacement  = "/metrics/resource"
        target_label = "__metrics_path__"
      }
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    prometheus.scrape "kubelet_resource" {
      targets    = discovery.relabel.kubelet_resource.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scheme            = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Kubelet probes metrics (local node only)
    discovery.relabel "kubelet_probes" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }
      rule {
        replacement  = "/metrics/probes"
        target_label = "__metrics_path__"
      }
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    prometheus.scrape "kubelet_probes" {
      targets    = discovery.relabel.kubelet_probes.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scheme            = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // ==========================================================================
    // NODE-LOCAL POD METRICS (no clustering - field selector scopes to this node)
    // Each DaemonSet pod scrapes only pods on its own node. Across 10 nodes,
    // all annotated pods get scraped exactly once.
    // ==========================================================================

    discovery.relabel "pods_metrics" {
      targets = discovery.kubernetes.pods.targets

      // Only scrape pods with prometheus.io/scrape=true annotation
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      // Honor prometheus.io/path annotation
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }

      // Honor prometheus.io/port annotation
      rule {
        source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }

      // Drop Mimir pods - they use memberlist and have separate ServiceMonitor
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        regex         = "mimir"
        action        = "drop"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
      // app label: prefer app.kubernetes.io/name, fall back to app label
      // Order matters: fallback first, preferred second (last write wins)
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex         = "(.+)"
        target_label  = "app"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        regex         = "(.+)"
        target_label  = "app"
      }
    }

    prometheus.scrape "kubernetes_pods" {
      targets    = discovery.relabel.pods_metrics.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // ==========================================================================
    // NODE-LOCAL CONTROL PLANE METRICS (no clustering - field selector scopes to
    // this node, so only CP alloy pods discover CP components)
    // ==========================================================================

    discovery.relabel "control_plane" {
      targets = discovery.kubernetes.pods.targets

      // Keep only kube-system namespace
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "kube-system"
        action        = "keep"
      }

      // Keep only control plane tier
      rule {
        source_labels = ["__meta_kubernetes_pod_label_tier"]
        regex         = "control-plane"
        action        = "keep"
      }

      // Keep only control plane components
      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        regex         = "(kube-apiserver|kube-scheduler|kube-controller-manager)"
        action        = "keep"
      }

      // Set address for scheduler (port 10259)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-scheduler"
        target_label  = "__address__"
        replacement   = "$1:10259"
      }

      // Set address for controller-manager (port 10257)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-controller-manager"
        target_label  = "__address__"
        replacement   = "$1:10257"
      }

      // Set address for API server (port 6443)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-apiserver"
        target_label  = "__address__"
        replacement   = "$1:6443"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        target_label  = "component"
      }
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        target_label  = "job"
      }
    }

    prometheus.scrape "control_plane" {
      targets    = discovery.relabel.control_plane.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      scheme            = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // ==========================================================================
    // CLUSTER-WIDE METRICS (clustering enabled - distributed across DaemonSet pods)
    // These targets exist cluster-wide; clustering ensures each is scraped by
    // exactly one alloy instance instead of all 10.
    // ==========================================================================

    // Kube-state-metrics (single target)
    discovery.relabel "kube_state_metrics" {
      targets = discovery.kubernetes.services.targets

      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        regex         = "kube-state-metrics"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "gossip-stone"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_name", "__meta_kubernetes_service_port_name"]
        regex         = "kube-state-metrics;http-metrics"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        replacement  = "kube-state-metrics"
        target_label = "job"
      }
    }

    prometheus.scrape "kube_state_metrics" {
      targets    = discovery.relabel.kube_state_metrics.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      clustering {
        enabled = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // CoreDNS (endpoints scoped to kube-system)
    discovery.relabel "coredns" {
      targets = discovery.kubernetes.endpoints.targets

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "kube-system"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        regex         = "(coredns|kube-dns)"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_endpoint_port_name"]
        regex         = "metrics"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        replacement  = "coredns"
        target_label = "job"
      }
    }

    prometheus.scrape "coredns" {
      targets    = discovery.relabel.coredns.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      clustering {
        enabled = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Service annotation-based scraping (cluster-wide)
    discovery.relabel "services_metrics" {
      targets = discovery.kubernetes.services.targets

      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }
      rule {
        source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_label_app_kubernetes_io_name"]
        regex         = "mimir"
        action        = "drop"
      }
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }
      rule {
        source_labels = ["__meta_kubernetes_service_label_app_kubernetes_io_name"]
        target_label  = "app"
      }
    }

    prometheus.scrape "kubernetes_services" {
      targets    = discovery.relabel.services_metrics.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      clustering {
        enabled = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Lighthouse Docker host exporters (static targets)
    discovery.relabel "lighthouse_exporters" {
      targets = [
        {
          __address__ = "10.55.6.137:9100",
          job         = "node-exporter-lighthouse",
          instance    = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:8098",
          job         = "cadvisor-lighthouse",
          instance    = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:9795",
          job         = "eaton-ups-exporter",
          instance    = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:9221",
          job         = "proxmox-pve-exporter",
          instance    = "lighthouse",
        },
      ]
    }

    prometheus.scrape "lighthouse_exporters" {
      targets    = discovery.relabel.lighthouse_exporters.output
      forward_to = [prometheus.relabel.drop_high_cardinality.receiver]

      clustering {
        enabled = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // ==========================================================================
    // LOG COLLECTION - Filesystem-based (loki.source.file)
    // Reads from /var/log/pods/ on the local node. Inherently node-scoped,
    // no API connections needed. Uses node-scoped pods discovery for metadata.
    // ==========================================================================

    loki.write "default" {
      endpoint {
        url = "http://loki-gateway.gossip-stone.svc.cluster.local/loki/api/v1/push"
      }
    }

    // Build log file paths from pod discovery metadata
    discovery.relabel "pods_logs" {
      targets = discovery.kubernetes.pods.targets

      // Construct __path__ from pod metadata: /var/log/pods/<ns>_<pod>_<uid>/<container>/*.log
      rule {
        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        separator     = "/"
        regex         = "(.+)/(.+)/(.+)/(.+)"
        replacement   = "/var/log/pods/$1_$2_$3/$4/*.log"
        target_label  = "__path__"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }
      // app label: prefer app.kubernetes.io/name, fall back to app label
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex         = "(.+)"
        target_label  = "app"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        regex         = "(.+)"
        target_label  = "app"
      }
      rule {
        source_labels = ["app"]
        target_label  = "job"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
    }

    local.file_match "pod_logs" {
      path_targets = discovery.relabel.pods_logs.output
    }

    loki.source.file "pod_logs" {
      targets    = local.file_match.pod_logs.targets
      forward_to = [loki.process.parse_cri.receiver]
    }

    // Parse CRI log format: <timestamp> <stream> <flags> <message>
    loki.process "parse_cri" {
      forward_to = [loki.process.filter_noise.receiver]

      stage.cri {}
    }

    // Filter out noisy non-actionable log lines
    loki.process "filter_noise" {
      forward_to = [loki.process.add_labels.receiver]

      stage.drop {
        expression = "err-mimir-sample-timestamp-too-old"
      }
      stage.drop {
        expression = "sample has been rejected because another sample with a more recent timestamp"
      }
    }

    // Extract log level
    loki.process "add_labels" {
      forward_to = [loki.write.default.receiver]

      stage.regex {
        expression = "(?i)(?P<level>debug|info|warn|warning|error|fatal|critical)"
      }

      stage.labels {
        values = {
          level = "",
        }
      }
    }
