apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
data:
  config.alloy: |
    // Kubernetes Service Discovery
    discovery.kubernetes "pods" {
      role = "pod"
    }

    discovery.kubernetes "nodes" {
      role = "node"
    }

    discovery.kubernetes "services" {
      role = "service"
    }

    discovery.kubernetes "endpoints" {
      role = "endpoints"
    }

    discovery.kubernetes "endpointslices" {
      role = "endpointslice"
    }

    discovery.kubernetes "ingresses" {
      role = "ingress"
    }

    // Prometheus Remote Write - Direct to Mimir Distributor
    // Mimir architecture: Alloy → Mimir Distributor → Mimir Ingester → Object Storage
    prometheus.remote_write "default" {
      endpoint {
        url = "http://mimir-distributor.gossip-stone.svc.cluster.local:8080/api/v1/push"

        // Queue config tuned for stability - minimal parallelism
        // Distributors have limited memory, keep load gentle
        queue_config {
          capacity          = 2500
          max_shards        = 4
          min_shards        = 1
          max_samples_per_send = 500
          batch_send_deadline  = "15s"
          min_backoff       = "500ms"
          max_backoff       = "30s"
          retry_on_http_429 = true
        }
      }
    }

    // Global metric relabeling - drop bloated cAdvisor container labels from ALL sources
    // Mimir's Kafka ingest has 10MB message limit, bloated labels exceed this
    // Reduces metric size by dropping 28+ useless container_label_* fields
    // Keeps: compose_project, compose_service, config_hash, container_number, image, working_dir
    prometheus.relabel "drop_container_labels" {
      forward_to = [prometheus.remote_write.default.receiver]

      // Step 1: Rename labels we want to keep to temporary names
      rule {
        source_labels = ["container_label_com_docker_compose_project"]
        target_label  = "compose_project_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["container_label_com_docker_compose_service"]
        target_label  = "compose_service_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["container_label_com_docker_compose_config_hash"]
        target_label  = "compose_config_hash_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["container_label_com_docker_compose_container_number"]
        target_label  = "compose_container_number_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["container_label_com_docker_compose_image"]
        target_label  = "compose_image_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["container_label_com_docker_compose_project_working_dir"]
        target_label  = "compose_working_dir_temp"
        regex         = "(.*)"
        replacement   = "$1"
      }

      // Step 2: Drop ALL container_label_* labels
      rule {
        action = "labeldrop"
        regex  = "container_label_.*"
      }

      // Step 3: Rename temp labels back to proper names
      rule {
        source_labels = ["compose_project_temp"]
        target_label  = "compose_project"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["compose_service_temp"]
        target_label  = "compose_service"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["compose_config_hash_temp"]
        target_label  = "compose_config_hash"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["compose_container_number_temp"]
        target_label  = "compose_container_number"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["compose_image_temp"]
        target_label  = "compose_image"
        regex         = "(.*)"
        replacement   = "$1"
      }

      rule {
        source_labels = ["compose_working_dir_temp"]
        target_label  = "compose_working_dir"
        regex         = "(.*)"
        replacement   = "$1"
      }

      // Step 4: Drop temp labels
      rule {
        action = "labeldrop"
        regex  = "compose_(project|service|config_hash|container_number|image|working_dir)_temp"
      }
    }

    // Built-in Node Exporter - exposes host metrics from each K8s node
    prometheus.exporter.unix "node_metrics" {
      // Use default collectors (CPU, memory, disk, network, filesystem, etc.)
    }

    // Scrape local node metrics from unix exporter
    prometheus.scrape "node_exporter" {
      targets    = prometheus.exporter.unix.node_metrics.targets
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel nodes for kubelet scraping
    discovery.relabel "kubelet" {
      targets = discovery.kubernetes.nodes.targets

      // Keep only the local node (filter by HOSTNAME env var)
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
        action        = "keep"
      }

      // Target kubelet metrics endpoint
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }

      // Set metrics path to kubelet endpoint
      rule {
        replacement  = "/metrics"
        target_label = "__metrics_path__"
      }

      // Add job label for kubelet metrics
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    // Scrape kubelet metrics (kubelet-specific metrics)
    prometheus.scrape "kubelet" {
      targets    = discovery.relabel.kubelet.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scheme          = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel nodes for cAdvisor scraping
    discovery.relabel "cadvisor" {
      targets = discovery.kubernetes.nodes.targets

      // Keep only the local node (filter by HOSTNAME env var)
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
        action        = "keep"
      }

      // Target kubelet cAdvisor metrics endpoint
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }

      // Set metrics path to cAdvisor endpoint
      rule {
        replacement  = "/metrics/cadvisor"
        target_label = "__metrics_path__"
      }

      // Add job label for cAdvisor metrics
      rule {
        replacement  = "cadvisor"
        target_label = "job"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    // Scrape cAdvisor metrics (container metrics from kubelet)
    prometheus.scrape "cadvisor" {
      targets    = discovery.relabel.cadvisor.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scheme          = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel nodes for resource metrics scraping (includes volume stats when enabled)
    discovery.relabel "kubelet_resource" {
      targets = discovery.kubernetes.nodes.targets

      // Keep only the local node (filter by HOSTNAME env var)
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
        action        = "keep"
      }

      // Target kubelet resource metrics endpoint
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }

      // Set metrics path to resource endpoint
      rule {
        replacement  = "/metrics/resource"
        target_label = "__metrics_path__"
      }

      // Add job label for kubelet resource metrics
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    // Scrape kubelet resource metrics (volume stats, pod resource metrics)
    prometheus.scrape "kubelet_resource" {
      targets    = discovery.relabel.kubelet_resource.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scheme          = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel nodes for probes metrics scraping
    discovery.relabel "kubelet_probes" {
      targets = discovery.kubernetes.nodes.targets

      // Keep only the local node (filter by HOSTNAME env var)
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = env("HOSTNAME")
        action        = "keep"
      }

      // Target kubelet probes metrics endpoint
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }

      // Set metrics path to probes endpoint
      rule {
        replacement  = "/metrics/probes"
        target_label = "__metrics_path__"
      }

      // Add job label for kubelet probes metrics
      rule {
        replacement  = "kubelet"
        target_label = "job"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        target_label  = "node"
      }
    }

    // Scrape kubelet probes metrics (liveness/readiness probe metrics)
    prometheus.scrape "kubelet_probes" {
      targets    = discovery.relabel.kubelet_probes.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scheme          = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel kube-state-metrics for scraping
    discovery.relabel "kube_state_metrics" {
      targets = discovery.kubernetes.services.targets

      // Keep only kube-state-metrics service
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        regex         = "kube-state-metrics"
        action        = "keep"
      }

      // Keep only gossip-stone namespace
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "gossip-stone"
        action        = "keep"
      }

      // Use service port
      rule {
        source_labels = ["__meta_kubernetes_service_name", "__meta_kubernetes_endpoint_port_name"]
        regex         = "kube-state-metrics;http-metrics"
        action        = "keep"
      }

      // Add service and namespace labels
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add job label for kube-state-metrics
      rule {
        replacement  = "kube-state-metrics"
        target_label = "job"
      }
    }

    // Scrape kube-state-metrics (Kubernetes object state)
    prometheus.scrape "kube_state_metrics" {
      targets    = discovery.relabel.kube_state_metrics.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel control plane static pods (API server, scheduler, controller-manager)
    discovery.relabel "control_plane" {
      targets = discovery.kubernetes.pods.targets

      // Keep only kube-system namespace
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "kube-system"
        action        = "keep"
      }

      // Keep only control plane tier
      rule {
        source_labels = ["__meta_kubernetes_pod_label_tier"]
        regex         = "control-plane"
        action        = "keep"
      }

      // Keep only control plane components
      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        regex         = "(kube-apiserver|kube-scheduler|kube-controller-manager)"
        action        = "keep"
      }

      // Set address for scheduler (port 10259)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-scheduler"
        target_label  = "__address__"
        replacement   = "$1:10259"
      }

      // Set address for controller-manager (port 10257)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-controller-manager"
        target_label  = "__address__"
        replacement   = "$1:10257"
      }

      // Set address for API server (port 6443)
      rule {
        source_labels = ["__meta_kubernetes_pod_ip", "__meta_kubernetes_pod_label_component"]
        regex         = "(.+);kube-apiserver"
        target_label  = "__address__"
        replacement   = "$1:6443"
      }

      // Add component label
      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        target_label  = "component"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }

      // Add job label from component
      rule {
        source_labels = ["__meta_kubernetes_pod_label_component"]
        target_label  = "job"
      }
    }

    // Scrape control plane metrics
    prometheus.scrape "control_plane" {
      targets    = discovery.relabel.control_plane.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scheme          = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel CoreDNS for scraping
    discovery.relabel "coredns" {
      targets = discovery.kubernetes.endpoints.targets

      // Keep only kube-system namespace
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "kube-system"
        action        = "keep"
      }

      // Keep only coredns service or kube-dns
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        regex         = "(coredns|kube-dns)"
        action        = "keep"
      }

      // Keep only metrics port
      rule {
        source_labels = ["__meta_kubernetes_endpoint_port_name"]
        regex         = "metrics"
        action        = "keep"
      }

      // Add service label
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add job label for coredns
      rule {
        replacement  = "coredns"
        target_label = "job"
      }
    }

    // Scrape CoreDNS metrics
    prometheus.scrape "coredns" {
      targets    = discovery.relabel.coredns.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel pod metrics targets for better organization
    discovery.relabel "pods_metrics" {
      targets = discovery.kubernetes.pods.targets

      // Only scrape pods with prometheus.io/scrape=true annotation (opt-in)
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      // Honor prometheus.io/path annotation for custom metrics paths
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }

      // Honor prometheus.io/port annotation for custom metrics ports
      rule {
        source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }

      // Drop Mimir pods - they use memberlist and get overwhelmed by HTTP scrape attempts on port 7946
      // Mimir exposes metrics via ServiceMonitor which is handled separately
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        regex         = "mimir"
        action        = "drop"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add pod name
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      // Add container name
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      // Add node name
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }

      // Add app label from app.kubernetes.io/name
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "app"
      }

      // Fallback: add app label from pod label app
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        regex         = "^$"
        target_label  = "app"
      }
    }

    // Scrape Kubernetes Pods with prometheus.io annotations
    prometheus.scrape "kubernetes_pods" {
      targets = discovery.relabel.pods_metrics.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      clustering {
        enabled = false
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Relabel service metrics targets for better organization
    discovery.relabel "services_metrics" {
      targets = discovery.kubernetes.services.targets

      // Only scrape services with prometheus.io/scrape=true annotation (opt-in)
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      // Honor prometheus.io/path annotation for custom metrics paths
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
      }

      // Honor prometheus.io/port annotation for custom metrics ports
      rule {
        source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
        regex         = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement   = "$1:$2"
        target_label  = "__address__"
      }

      // Drop Mimir services - they use memberlist and have their own scraping setup
      rule {
        source_labels = ["__meta_kubernetes_service_label_app_kubernetes_io_name"]
        regex         = "mimir"
        action        = "drop"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add service name
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        target_label  = "service"
      }

      // Add app label
      rule {
        source_labels = ["__meta_kubernetes_service_label_app_kubernetes_io_name"]
        target_label  = "app"
      }
    }

    // Scrape Kubernetes Services with prometheus.io/scrape annotation
    prometheus.scrape "kubernetes_services" {
      targets = discovery.relabel.services_metrics.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      clustering {
        enabled = false
      }

      scrape_interval = "30s"
      scrape_timeout  = "10s"
    }

    // Loki Log Collection - Local K8s Loki
    loki.write "default" {
      endpoint {
        url = "http://loki-gateway.gossip-stone.svc.cluster.local/loki/api/v1/push"
      }
    }

    // Relabel pod targets for better log organization
    discovery.relabel "pods_logs" {
      targets = discovery.kubernetes.pods.targets

      // Keep namespace
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Keep pod name
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      // Keep container name
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      // Add app label from pod label app.kubernetes.io/name or app
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "app"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        target_label  = "app"
      }

      // Add job label (use app or fallback to namespace/pod)
      rule {
        source_labels = ["app"]
        target_label  = "job"
      }
      rule {
        source_labels = ["namespace", "pod"]
        separator     = "/"
        target_label  = "job"
        regex         = "^$"  // Only if job is empty
      }

      // Keep node name
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
    }

    // Collect logs from Kubernetes pods with proper labels
    loki.source.kubernetes "pods" {
      targets    = discovery.relabel.pods_logs.output
      forward_to = [loki.process.add_labels.receiver]
    }

    // Add additional processing and labels
    loki.process "add_labels" {
      forward_to = [loki.write.default.receiver]

      // Extract log level from common patterns
      stage.regex {
        expression = "(?i)(?P<level>debug|info|warn|warning|error|fatal|critical)"
      }

      stage.labels {
        values = {
          level = "",
        }
      }
    }

    // Remote scrape targets (lighthouse Docker host @ 10.55.6.137)
    discovery.relabel "lighthouse_exporters" {
      targets = [
        {
          __address__ = "10.55.6.137:9100",
          job = "node-exporter-lighthouse",
          instance = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:8098",
          job = "cadvisor-lighthouse",
          instance = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:9795",
          job = "eaton-ups-exporter",
          instance = "lighthouse",
        },
        {
          __address__ = "10.55.6.137:9221",
          job = "proxmox-pve-exporter",
          instance = "lighthouse",
        },
      ]
    }

    prometheus.scrape "lighthouse_exporters" {
      targets    = discovery.relabel.lighthouse_exporters.output
      forward_to = [prometheus.relabel.drop_container_labels.receiver]

      scrape_interval = "30s"
      scrape_timeout  = "10s"

      clustering {
        enabled = false
      }
    }
