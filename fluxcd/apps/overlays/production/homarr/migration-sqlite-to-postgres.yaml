---
apiVersion: v1
kind: ConfigMap
metadata:
  name: homarr-migration-script
  namespace: lost-woods
data:
  migrate.py: |
    #!/usr/bin/env python3
    import sqlite3
    import psycopg2
    import os
    import sys

    def get_table_info(sqlite_cursor, table_name):
        """Get column information from SQLite table."""
        sqlite_cursor.execute(f'PRAGMA table_info("{table_name}")')
        return sqlite_cursor.fetchall()

    def get_sqlite_tables(sqlite_cursor):
        """Get list of all tables from SQLite database."""
        sqlite_cursor.execute("""
            SELECT name FROM sqlite_master
            WHERE type='table'
            AND name NOT LIKE 'sqlite_%'
            ORDER BY name
        """)
        return [row[0] for row in sqlite_cursor.fetchall()]

    def get_pg_column_types(pg_cursor, table_name):
        """Get PostgreSQL column types for a table."""
        pg_cursor.execute("""
            SELECT column_name, data_type
            FROM information_schema.columns
            WHERE table_name = %s AND table_schema = 'public'
        """, (table_name,))
        return {row[0]: row[1] for row in pg_cursor.fetchall()}

    def convert_value(value, column_name, pg_data_type):
        """Convert SQLite values to PostgreSQL compatible values."""
        if value is None:
            return None

        # Boolean columns (SQLite stores as 0/1, PostgreSQL expects true/false)
        if pg_data_type == 'boolean':
            return bool(value)

        # Timestamp columns (SQLite stores as Unix timestamp integers)
        if pg_data_type in ('timestamp without time zone', 'timestamp with time zone'):
            if isinstance(value, int):
                # Convert Unix timestamp (milliseconds) to ISO format
                from datetime import datetime
                return datetime.fromtimestamp(value / 1000.0).isoformat()
            return value

        return value

    def migrate_table(sqlite_cursor, pg_cursor, table_name):
        """Migrate a single table from SQLite to PostgreSQL."""
        print(f"Migrating table: {table_name}")

        # Get column names and types from SQLite
        columns_info = get_table_info(sqlite_cursor, table_name)
        if not columns_info:
            print(f"  Skipping {table_name}: no columns found")
            return 0

        column_names = [col[1] for col in columns_info]

        # Get PostgreSQL column types
        pg_column_types = get_pg_column_types(pg_cursor, table_name)

        # Count rows
        sqlite_cursor.execute(f'SELECT COUNT(*) FROM "{table_name}"')
        row_count = sqlite_cursor.fetchone()[0]

        if row_count == 0:
            print(f"  Skipping {table_name}: empty table")
            return 0

        print(f"  Found {row_count} rows")

        # Fetch all data from SQLite
        sqlite_cursor.execute(f'SELECT * FROM "{table_name}"')
        rows = sqlite_cursor.fetchall()

        if not rows:
            print(f"  No data to migrate for {table_name}")
            return 0

        # Convert values for PostgreSQL
        converted_rows = []
        for row in rows:
            converted_row = tuple(
                convert_value(value, column_names[i], pg_column_types.get(column_names[i]))
                for i, value in enumerate(row)
            )
            converted_rows.append(converted_row)

        # Prepare INSERT statement for PostgreSQL
        # Use quoted identifiers to preserve case
        quoted_columns = [f'"{col}"' for col in column_names]
        placeholders = ', '.join(['%s'] * len(column_names))
        insert_sql = f'''
            INSERT INTO "{table_name}" ({', '.join(quoted_columns)})
            VALUES ({placeholders})
            ON CONFLICT DO NOTHING
        '''

        # Insert data into PostgreSQL
        try:
            pg_cursor.executemany(insert_sql, converted_rows)
            print(f"  ✓ Migrated {len(converted_rows)} rows to {table_name}")
            return len(converted_rows)
        except Exception as e:
            print(f"  ✗ Error migrating {table_name}: {e}")
            raise

    def main():
        # Database connections
        sqlite_db = os.getenv('SQLITE_DB', '/appdata/db/db.sqlite')
        pg_host = os.getenv('DB_HOST', 'homarr-postgres-rw')
        pg_port = os.getenv('DB_PORT', '5432')
        pg_user = os.getenv('DB_USER', 'homarr')
        pg_password = os.getenv('DB_PASSWORD')
        pg_database = os.getenv('DB_NAME', 'homarr')

        if not pg_password:
            print("Error: DB_PASSWORD environment variable is required")
            sys.exit(1)

        print(f"Connecting to SQLite database: {sqlite_db}")
        print(f"Connecting to PostgreSQL: {pg_host}:{pg_port}/{pg_database}")

        # Connect to databases
        sqlite_conn = sqlite3.connect(sqlite_db)
        sqlite_cursor = sqlite_conn.cursor()

        pg_conn = psycopg2.connect(
            host=pg_host,
            port=pg_port,
            user=pg_user,
            password=pg_password,
            database=pg_database
        )
        pg_cursor = pg_conn.cursor()

        try:
            # Disable foreign key constraints for migration
            # This allows us to insert data without worrying about circular dependencies
            print("Disabling foreign key constraints...")
            pg_cursor.execute("SET session_replication_role = 'replica';")
            pg_conn.commit()

            # Get list of tables from SQLite
            all_tables = get_sqlite_tables(sqlite_cursor)
            print(f"\nFound {len(all_tables)} tables to migrate:")
            for table in all_tables:
                print(f"  - {table}")

            # Define dependency order for tables
            # Parent tables must be migrated before child tables
            table_order = [
                'user',
                'group',
                'account',
                'groupMember',
                'groupPermission',
                'board',
                'boardGroupPermission',
                'boardUserPermission',
                'layout',
                'section',
                'section_layout',
                'section_collapse_state',
                'item',
                'item_layout',
                'iconRepository',
                'icon',
                'integration',
                'integrationGroupPermissions',
                'integrationSecret',
                'integrationUserPermission',
                'integration_item',
                'media',
                'serverSetting',
                'search_engine',
                'onboarding',
                'session',
                'invite',
                'verificationToken',
                'cron_job_configuration',
                'apiKey',
                'app',
                'trusted_certificate_hostname',
            ]

            # Sort tables by dependency order
            tables = []
            for table in table_order:
                if table in all_tables:
                    tables.append(table)

            # Add any remaining tables not in our order list
            for table in all_tables:
                if table not in tables:
                    tables.append(table)

            print("\nStarting migration...\n")

            # Migrate each table
            total_rows = 0
            for table in tables:
                # Skip system/internal tables
                if table.startswith('__') or table.startswith('sqlite_'):
                    print(f"Skipping system table: {table}")
                    continue

                try:
                    rows_migrated = migrate_table(sqlite_cursor, pg_cursor, table)
                    total_rows += rows_migrated
                    # Commit after each table to avoid transaction abort
                    pg_conn.commit()
                except Exception as e:
                    print(f"Error migrating {table}: {e}")
                    print("Rolling back this table and continuing...")
                    pg_conn.rollback()
                    continue

            print(f"\n✓ Migration complete!")
            print(f"Total rows migrated: {total_rows}")

            # Mark onboarding as completed to prevent setup screen
            print("\nMarking onboarding as completed...")
            pg_cursor.execute("""
                UPDATE "onboarding"
                SET step = 'finish', previous_step = 'start'
                WHERE step = 'start'
            """)
            updated_rows = pg_cursor.rowcount
            pg_conn.commit()
            if updated_rows > 0:
                print(f"  ✓ Updated {updated_rows} onboarding record(s) to 'finish' state")
            else:
                print("  ℹ No onboarding records needed updating")

            # Re-enable foreign key constraints
            print("\nRe-enabling foreign key constraints...")
            pg_cursor.execute("SET session_replication_role = 'origin';")
            pg_conn.commit()

        except Exception as e:
            print(f"\n✗ Migration failed: {e}")
            # Re-enable foreign key constraints even on failure
            try:
                pg_cursor.execute("SET session_replication_role = 'origin';")
                pg_conn.commit()
            except:
                pass
            pg_conn.rollback()
            sys.exit(1)
        finally:
            sqlite_cursor.close()
            sqlite_conn.close()
            pg_cursor.close()
            pg_conn.close()

    if __name__ == '__main__':
        main()
---
apiVersion: batch/v1
kind: Job
metadata:
  name: homarr-sqlite-to-postgres-migration
  namespace: lost-woods
spec:
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: migration
        image: docker.io/python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "Installing dependencies..."
          pip install --quiet psycopg2-binary
          echo "Starting migration..."
          python3 /scripts/migrate.py
        env:
        - name: SQLITE_DB
          value: "/appdata/db.sqlite"
        - name: DB_HOST
          value: "homarr-postgres-rw"
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "homarr"
        - name: DB_USER
          value: "postgres"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: homarr-postgres-superuser
              key: password
        volumeMounts:
        - name: sqlite-data
          mountPath: /appdata
          readOnly: true
        - name: migration-script
          mountPath: /scripts
      volumes:
      - name: sqlite-data
        persistentVolumeClaim:
          claimName: lost-woods-homarr-sqlite-homarr-0
      - name: migration-script
        configMap:
          name: homarr-migration-script
          defaultMode: 0755
